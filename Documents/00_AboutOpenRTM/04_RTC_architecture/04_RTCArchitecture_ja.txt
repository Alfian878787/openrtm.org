#contents

** RTコンポーネントフレームワーク

RTコンポーネントを作成するためのフレームワークです。

ロボットシステムを構成する要素をモジュール化するとき、様々な粒度でのモジュール化が考えられます。たとえば、モーターやセンサーといった単機能のデバイス、移動ロボットやアームなど複合的なシステム、あるいは様々な処理を行うアルゴリズムといった単位が考えられ、それらの階層的な集積によりシステムが構築されます。RTミドルウエアでは、これらのRT機能要素の本質的なソフトウエア部分をコアロジックと呼びます。RTコンポーネントフレームワークは、コアロジックに共通のインターフェースという皮を被せて、これらのモジュールを統一的に扱うことができるようにするための仕組みです。

#ref(rtc_framework_ja.png,30%,center)
CENTER: ''RTコンポーネントフレームワークとコアロジック''

上図のように、ステレオビジョンのアルゴリズムをコンポーネント化する例を考えると、アルゴリズムを実装したプログラムそのものはコアロジックに相当します。適切なポートを設定したRTコンポーネントフレームワークを基に、ステレオビジョンアルゴリズムをこのフレームワークに実装してやることで、ステレオビジョンコンポーネントを作ることができます。このように、コンポーネントフレームワークに基づきコンポーネント開発者がコアロジックを実装しシステムに組み込むことができるようにしたモジュールを、RTコンポーネントと呼びます。RTコンポーネントフレームワークは、共通インターフェースの実装を、コンポーネント開発者や、コンポーネントを組合わせてシステムを構築するインテグレータに対して隠蔽します。こうすることによって、コンポーネント開発者はメインのロジックの実装に集中でき、インテグレータは実装の詳細を気にすることなくシステム全体の設計に集中することができます。

** RTコンポーネントアーキテクチャ

RTシステムでは、低レベルのセンサ処理やアクチュエータ制御から、高レベルの認識、判断、行動制御など、様々なレベルの処理を連携して行う必要があります。低レベルの制御プログラムには、速度やリアルタイム性の要求を満たす言語が求められる一方で、高レベルのプログラムには、抽象度や記述力の高い言語が求められます。また、現在のRTシステムは、複数のCPUで構成されるケースが増えており、並列制御やネットワークを介した連携機能も必要です。

これらの機能要素をモジュール化するため、RTコンポーネントは、様々な粒度でモジュール化が可能で、かつ、多様な言語、OS上で動作する分散コンポーネント型のフレームワークを提供しています。

図にRTCの基本的なアーキテクチャを示します。RTCの主な機能としては以下のものがあります。

#ref(rtc_architecture_ja.png,30%,center)
CENTER: ''RTコンポーネントアーキテクチャ''

*** メタ情報取得

RTCはメタ情報(RTCプロファイル)取得のためのインターフェース(イントロスペクション機能)を持ちます。RTCプロファイルとは、コンポーネントの名前や所有しているポートのプロファイルなど、コンポーネントの特性を表わす一連の情報です。この機能は実行時の動的なシステム構成時に必要となります。

> イントロスペクション: 日本語で内省と訳される、オブジェクトやコンポーネントのメタ情報を取得する仕組みのこと。定義は一定していないが、Java におけるリフレクションと類似の機能。OMG RTC仕様ではこの機能をintrospectionと定義している。

#ref(rtc_arch_introspection_ja.png,40%,center)
CENTER: ''メタ情報取得''

*** アクティビティ

コンポーネン内の主たるロジックを実行する仕組み。RTCの統一的管理のため、Inactive(OFF状態)、Active(ON状態)、Error(エラー状態)等の共通の状態が決められています。RTC開発者は、主に、それぞれの状態や状態遷移イベントに割り当てられた関数(コールバック関数)に実現したい機能を実装することでRTCを作成します。

#ref(rtc_arch_activity_ja.png,40%,center)
CENTER: ''アクティビティと実行コンテキスト''

*** 実行コンテキスト

アクティビティを構成するコールバック関数は、実行コンテキスト(Execution Context: EC)と呼ばれるスレッドにより実行されます。ECは、RTCに対して動的にアタッチ/デタッチ可能で、一つのECを複数のRTCにアタッチし、直列に同期的に実行させたり、リアルタイム実行可能なECと入れ替えることでRTCの実行をリアルタイム化することも可能です。

*** データポート

連続的なデータの送受信を行うためのデータ指向ポート。入力ポート(InPort)と出力ポート(OutPort)の2種類があり、同じデータ型同士なら、言語やOSが異なっていても、ネットワークを介して接続/通信することができます。

#ref(rtc_arch_dataport_ja.png,40%,center)
CENTER: ''データポート''

*** サービスポート

コマンドレベルの詳細な機能の提供/利用を行うポートです。ユーザー定義可能なプロバイダ(提供(Provided)インターフェース)とコンシューマー(要求(Required)インターフェース)があり、それぞれ外部に機能を提供するインターフェースをProvided Interface、外部の機能を要求/利用するインターフェースをRequired Interfaceと呼びます。データポート同様、言語、OSが異なっていてもインターフェース型が同じなら接続し関数を呼び出すことができます。

#ref(rtc_arch_serviceport_ja.png,40%,center)
CENTER: ''サービスポート''

*** コンフィギュレーション

ユーザー定義のパラメーターを、実行時に外部から変更するための機能。複数のパラメーターセットを持ち、それらを一斉に入れ替えることができます。パラメーターを予め変更可能にしておくことで、RTCを様々なシステムで再利用可能にします。

#ref(rtc_arch_configuration_ja.png,40%,center)
CENTER: ''コンフィギュレーション''


一般に、RTシステムにおける低レベル部分では、サーボコントローラー等粒度が細かくデータ指向の密結合なサブシステムが主体であり、判断や振る舞いを決める高レベルの部分では、粒度の粗いサービス指向のサブシステムが主体となります。RTCでは、こうした多様な粒度のモジュール化を共通のフレームワークで実現しているため、階層化フレームワークで問題となる、階層間の結合は問題となりません。

異なる言語、およびOS上のRTC間の透過的連携は、分散オブジェクトミドルウエアの標準仕様であるCORBA(Common Object Request Broker Architecture)を利用することで実現されています。
