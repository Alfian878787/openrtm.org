#contents

** RTコンポーネントフレームワーク

RTコンポーネントを作成するためのフレームワークです。

ロボットシステムを構成する要素をモジュール化するとき、様々な粒度でのモジュール化が考えられます。たとえば、モーターやセンサーといった単機能のデバイス、移動ロボットやアームなど複合的なシステム、あるいは様々な処理を行うアルゴリズムといった単位が考えられ、それらの階層的な集積によりシステムが構築されます。RTミドルウエアでは、これらの RT機能要素の本質的なソフトウエア部分をコアロジックと呼びます。RTコンポーネントフレームワークは、コアロジックに共通のインターフェースという皮を被せて、これらのモジュールを統一的に扱うことができるようにするための仕組みです。

#ref(rtc_framework_ja.png,30%,center)
CENTER: ''RTコンポーネントフレームワークとコアロジック''

上図のように、ステレオビジョンのアルゴリズムをコンポーネント化する例を考えると、アルゴリズムを実装したプログラムそのものはコアロジックに相当します。適切なポートを設定した RTコンポーネントフレームワークを用意してやり、ステレオビジョンアルゴリズムをこのフレームワークに実装してやることで、ステレオビジョンコンポーネントを作ることができます。このように、コンポーネントフレームワークに基づきコンポーネント開発者がコアロジックを実装し、システムに組み込むことができるようにしたモジュールを RTコンポーネントと呼びます。RTコンポーネントフレームワークは、共通インターフェースやその振る舞いをコンポーネント開発者や、コンポーネントを組合わせてシステムを構築するインテグレータから隠蔽します。こうすることによって、コンポーネント開発者はメインのロジックの実装に集中でき、インテグレータは実装の詳細を気にすることなくシステム全体の設計に集中することができます。

** RTコンポーネントアーキテクチャ

RTシステムでは、低レベルのセンサ処理やアクチュエータ制御から、高レベルの認識、判断、行動制御など、様々なレベルの処理を連携して行う必要があります。低レベルの制御プログラムには、速度やリアルタイム性の要求を満たす言語が求められる一方で、高レベルのプログラムには、抽象度や記述力の高い言語が求められます。また、現在のRTシステムは、複数の CPU で構成されるケースが増えており、並列制御やネットワークを介した連携機能も必要です。

これらの機能要素をモジュール化するため、RTコンポーネントは、様々な粒度でモジュール化が可能で、かつ、多様な言語、OS上で動作する、分散コンポーネント型のフレームワークを提供しています。

図に RTC の基本的なアーキテクチャを示します。RTC の主な機能としては以下のものがあります。

#ref(rtc_architecture_ja.png,30%,center)
CENTER: ''RTコンポーネントアーキテクチャ''

*** メタ情報取得

RTC はメタ情報 (RTC プロファイル) 取得のためのインターフェース (イントロスペクション機能) を持ちます。RTC プロファイルとは、コンポーネントの名前や所有しているポートのプロファイルなど、コンポーネントの特性を表わす一連の情報です。この機能は実行時の動的なシステム構成時に必要となります。

> イントロスペクション: 日本語で内省と訳される、オブジェクトやコンポーネントのメタ情報を取得する仕組みのこと. 定義は一定していないが、Java におけるリフレクションと類似の機能. OMG RTC 仕様ではこの機能を introspection と定義している。

#ref(rtc_arch_introspection_ja.png,40%,center)
CENTER: ''メタ情報取得''

*** アクティビティ

コンポーネントの主たる機能を実行する部分。RTC の統一的管理のため、Inactive (OFF状態)、Active (ON状態)、Error (エラー状態)といった共通の状態遷移が決められています。RTC開発者は、主にそれぞれの状態やイベントに割り当てられた関数 (コールバック関数) に実現したい機能を実装することで RTC を作成します。

#ref(rtc_arch_activity_ja.png,40%,center)
CENTER: ''アクティビティと実行コンテキスト''

*** 実行コンテキスト

アクティビティの関数は、実行コンテキスト (Execution Context: EC) と呼ばれるスレッドにより実行されます。ECは、RTC に対して動的にアタッチ・デタッチ可能で、一つの EC を複数の RTC にアタッチし、直列に同期的に実行させたり、リアルタイム実行可能な EC と入れ替えることで RTC の実行をリアルタイム化することも可能です。

*** データポート

連続的なデータの送受信を行うためのデータ指向ポート。入力ポート (InPort) と出力ポート (OutPort) の2種類があり、同じデータ型同士なら、言語や OS が異なっていても、ネットワークを介して接続・通信することができます。

#ref(rtc_arch_dataport_ja.png,40%,center)
CENTER: ''データポート''

*** サービスポート

コマンドレベルの詳細な機能の提供・利用を行う、ユーザー定義のプロバイダ(提供(Provided)インターフェース)や、コンシューマー(要求 (Required) インターフェース)を持たせることができるポート (外部に機能を提供するインターフェースを Provided Interface、外部の機能を要求・利用するインターフェースを Required Interface と呼びます。)。データポート同様、言語、OS が異なっていてもインターフェース型が同じなら接続し関数を呼び出すことができます。

#ref(rtc_arch_serviceport_ja.png,40%,center)
CENTER: ''データポート''

*** コンフィギュレーション

ユーザー定義のパラメーターを、実行時に外部から変更するための機能。複数のパラメーターセットを持ち、それらを一斉に入れ替えることができます。パラメーターを予め変更可能にしておくことで、RTC を様々なシステムで再利用可能にします。

#ref(rtc_arch_configuration_ja.png,40%,center)
CENTER: ''コンフィギュレーション''


一般に、RTシステムにおける低レベル部分では、サーボコントローラー等粒度が細かくデータ指向の密結合なサブシステムが主体であり、判断や振る舞いを決める高レベルの部分では、粒度の粗いサービス指向のサブシステムが主体となります。RTC では、こうした多様な粒度のモジュール化を共通のフレームワークで実現しているため、階層化フレームワークで問題となる、階層間の結合は問題となりません。

異なる言語、および OS 上の RTC 間の透過的連携は、分散オブジェクトミドルウエアの標準仕様である CORBA (Common Object Request Broker Architecture) を利用することで実現されています。
