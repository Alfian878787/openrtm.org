#contents

本節では、RTミドルウエア (OpenRTM-aist) を利用した、RTコンポーネントの開発方法について説明します。

** 開発の流れ

OpenRTM-aist は、コンポーネント化のためのフレームワークと、コンポーネントを管理・実行するためのミドルウエアから構成されています。

OpenRTM-aist は、コンポーネントを開発したいユーザー (コンポーネントデベロッパ) が持つ既存のソフトウエア資産、あるいは新たに作成したソフトウエアを容易に RTC 化するためのフレームワークを提供します。コンポーネント作成の大まかな流れは下図のようになります。

#ref(rtc_devel_flow_ja.png,40%,center)
CENTER: ''RTC および RTシステム開発の流れ''

上述したように、RTコンポーネントが持つ共通インターフェースに関するコード、他のコンポーネントとのデータのやり取りの処理などは、RTコンポーネントフレームワークにより隠蔽されています。これらの処理は共通であるため、多くの部分はライブラリ化や自動生成が可能です。OpenRTM-aist では RTC の雛型を生成するためのツールとして RTCBuilder を提供しています。

RTC 開発者は、自分が開発した既存のプログラムをコンポーネントフレームワークに組み込むことで RTコンポーネントを作成し、複数の RTC を組合わせてロボットシステムを構築します。既存のソフトウエア資源をソフトウエア部品である RTコンポーネントとして作成しておけば、様々な場面での再利用が容易になります。作成された RTC は、ネットワーク上の適当な場所に配置し、任意の場所から利用することができます。

RTC フレームワークに則って作成された RTC は大きく分けて2種類の形態があります。スタンドアロンRTC (Standalone RT-Component) は、単一の実行形式のバイナリ、ローダブルモジュールRTC (Loadable Module RT-Component) は動的にロード可能なバイナリファイルであり、1プロセスで複数種類の RTC を同時起動する際等に利用されます。

** RTCBuilder によるひな形コードの作成

RTCBuilder は RTコンポーネントの雛型コードを自動生成する開発ツールです。
RTC の基本プロファイルやデータポート、サービスポート、コンフィギュレーションに関する情報を入力することで大半のコードを自動生成します。対応している言語は、C++、Java、Python、C#です。  コンポーネントを作成する前に、おおよそ以下のことを決めておきます。

- プロファイル (名前、カテゴリ名、バージョン等)
- データポート (InPort・OutPort、ポート名、データ型)
- サービスポート  (ポート名、サービスインターフェース)
- コンフィギュレーション (変数の名前、変数の型)

Eclipseメニューの [ファイル] > [新規] > [その他] を選択してダイアログを開き、「その他」から「RTCBuilder」選択して [次へ] をクリックする。プロジェクト名を入力して [終了] をクリックします。図の画面が表示され、RTCBuilderには、「基本」「アクティビティ」「データポート」「サービスポート」「コンフィギュレーション」「ドキュメント生成」「言語・環境」「RTC.xml」のタブがあります。「基本」から「言語・環境」までのタブで順に必要に応じて項目を埋めていき、最後に、「基本」タブにある、「Output Project」 で先ほど入力したプロジェクト名を選択し、[コード生成] ボタンをクリックすることで、雛型コードが生成されます。生成されたコードは、Eclipse 起動時に指定したワークスペース内にあるプロジェクト名のフォルダーに保存されます。

#ref(rtcbuilder_ja.png,30%,center)
CENTER: ''RTCBuilder の開発画面''

** RTC の実装

RTコンポーネントのプログラムには通常のプログラムとは異なり、main関数に直接処理を実装することはありません。ここでは、例として C++版の実装について述べます。

RTコンポーネントは、ある基底クラスを継承した一つのクラスとして実装されます。 RTコンポーネントにおいてロジックが行う処理は、その基底クラスのメンバ関数(メソッド)をオーバーライドする形で記述します。例えば、初期化時に行う処理は、''onInitialize'' 関数の中に、RTC がアクティブ時に周期的に処
理したい内容は ''onExecute'' 関数に記述する。 

 class MyComponent
  : public DataflowComponentBase
 {
 public:
   // 初期化時に実行したい処理
   virtual ReturnCode_t onInitialize()
   {
     if (mylogic.init())
       return RTC::RTC_OK;
     return RTC::RTC_ERROR;
   }
 
   // 周期的に実行したい処理
   virtual ReturnCode_t onExecute(RTC::UniqueId ec_id)
   {
     if (mylogic.do_someting())
       return RTC::RTC_OK;
     RTC::RTC_ERROR;
   }
 
 private:
   MyLogic mylogic;
   // ポート等の宣言
   //   ：
 };

上記は C++ での実装例です。 この例では、クラス宣言と実装が一体となっていますが、実際にはヘッダファイル (.h) と実装ファイル(.cpp) に分割されてコードが生成されます。 MyLogic クラスのオブジェクト mylogic は、このコンポーネントが実際に行うコアロジックが実装されたクラスです。
例では、非常に簡潔に mylogic の関数を呼ぶことで RTC が実装されていますが、実際の実装でも、コアロジックを予めこの程度簡単に利用できるクラス化しておき、RTC 内での呼び出しは最低限にする方がよいでしょう。

RTCBuilder により同時に生成される Makefile やプロジェクトファイルでこのコードをコンパイルすることで、実行ファイルと共有オブジェクト(又はDLL)が生成される。

** RTC ライフサイクル

上述したように、RTC の実装では、予め決められた関数 (コールバック関数) に処理を記述することで、コンポーネントを作成します。 どのような関数があり、どういったタイミングで呼ばれるのかを知るためには、RTC の状態遷移すなわちライフサイクルを理解する必要があります。下図に、RTC の状態遷移図を示します。

#ref(rtc_state_machine_ja.png,40%,center)
CENTER: ''RTC ライフサイクル (UML ステートマシン図)''

コンポーネントは基本的に以下の状態を持つ。 

- 生成状態(Created)
- 活動状態(Alive)
-- 非アクティブ状態 (Inactive)
-- アクティブ状態 (Active)
-- エラー状態 (Error)
- 終了状態

これらの各状態や遷移時には、予め決められた関数 (コールバック関数) が EC によって呼び出されます。 表に、コールバック関数とそれぞれが呼ばれるタイミングを示します。

| 関数名        | 概要                                       |
| onInitialize  | ライフサイクル初期化時に1度だけ呼ばれる。  |
| onActivated   | アクティブ化する際に1回呼ばれる。          |
| onDeactivated | 非アクティブ化する際に1回呼ばれる。        |
| onExecute     | アクティブ状態にあるとき周期的に呼ばれる。 |
| onStateUpdate | onExecute の後に毎回呼ばれる。             |
| onAborting    | エラー状態に移行する際に1回呼ばれる。      |
| onError       | エラー状態にあるとき周期的に呼ばれる。     |
| onReset       | エラー状態から復帰する際に1回呼ばれる。    |
| onShutdown    | ECの駆動が停止する際に1回呼ばれる。        |
| onStartup     | ECの駆動が開始する際に1回呼ばれる。        |
| onFinalize    | ライフサイクル終了時に1度だけ呼ばれる。    |

