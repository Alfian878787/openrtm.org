#contents

本節では、RTミドルウエア：OpenRTM-aist を利用した、RTコンポーネントの開
発方法について説明します。

** 開発の流れ

OpenRTM-aistはコンポーネント化のためのフレームワークと、コンポーネント
を管理・実行するためのミドルウエアから構成されています。

OpenRTM-aist は、コンポーネントを開発したいユーザ (コンポーネントデベロッ
パ) が持つ既存のソフトウエア資産、あるいは新たに作成したソフトウエアを
容易にRTC化するためのフレームワークを提供します。コンポーネント作成の大
まかな流れは下図のようになります。

#ref(rtc_devel_flow_ja.png,40%,center)
CENTER: ''RTCおよびRTシステム開発の流れ''

上述したように、RTコンポーネントが持つ共通インターフェースに関するコー
ド、他のコンポーネントとのデータのやり取りの処理などは、RTコンポーネン
トフレームワークにより隠蔽されています。これらの処理は共通であるため、多
くの部分はライブラリ化や自動生成が可能です。OpenRTM-aistではRTCの雛型
を生成するためのツールとしてRTCBuilderを提供しています。

RTC開発者は、自分が開発した既存のプログラムをコンポーネントフレームワー
クに組み込むことでRTコンポーネントを作成し、複数のRTCを組合わせてロボッ
トシステムを構築します。既存のソフトウエア資源をソフトウエア部品であるRT
コンポーネントとして作成しておけば、様々な場面での再利用が容易になります。
作成されたRTCは、ネットワーク上の適当な場所に配置し、任意の場所から利用
することができます。

RTCフレームワークに則って作成されたRTCは大きく分けて2種類の形態がありま
す。  スタンドアロンRTC (Standalone RT-Component) は、単一の実行形式の
バイナリ、ローダブルモジュールRTC (Loadable Module RT-Component) は動的
にロード可能なバイナリファイルであり、1プロセスで複数種類のRTCを同時起
動する際等に利用されます。

** RTCBuilderによるひな形コードの作成

RTCBuilder は RTコンポーネントの雛型コードを自動生成する開発ツールです。
RTCの基本プロファイルやデータポート、サービスポート、コンフィギュレーショ
ンに関する情報を入力することで大半のコードを自動生成します。対応してい
る言語は、C++、Java、Python、C#です。  コンポーネントを作成する前に、お
およそ以下のことを決めておきます。

- プロファイル (名前、カテゴリ名、バージョン等)
- データポート (InPort・OutPort、ポート名、データ型)
- サービスポート  (ポート名、サービスインターフェース)
- コンフィギュレーション (変数の名前、変数の型)

Eclipseメニューの「ファイル」「新規」でダイアログを開き、「その他」から
「RTCBUilder」プロジェクトを選択しプロジェクト名を入力すると、図の画面
が現れます。RTCBuilderには、「基本」「アクティビティ」「データポート」
「サービスポート」「コンフィギュレーション」「ドキュメント生成」「言語・
環境」「RTC.xml」のタブがあり、「基本」から「言語・環境」までのタブで順
に必要に応じて項目を埋めていき、最後に、「基本」タブにある、Output
Projectで先ほど入力したプロジェクト名を選択し、「コード生成」ボタンを押
すことで、雛型コードが生成されます。生成されたコードは、Eclipse起動時に
指定したワークスペース内のプロジェクト名ディレクトリに保存されます。

#ref(rtcbuilder_ja.png,30%,center)
CENTER: ''RTCBuilderの開発画面''

** RTCの実装

RTコンポーネントのプログラムには通常のプログラムとは異なり、main関数に
直接処理を実装することはありません。ここでは、例としてC++版の実装について述べ
ます。

RTコンポーネントは、ある基底クラスを継承した一つのクラスとして実装され
ます。 RTコンポーネントにおいてロジックが行う処理は、その基底クラスのメン
バ関数(メソッド)をオーバーライドする形で記述します。例えば、初期化時に行
う処理は、''onInitialize'' 関数の中に、RTCがアクティブ時に周期的に処
理したい内容は ''onExecute'' 関数に記述する。 

 class MyComponent
  : public DataflowComponentBase
 {
 public:
   // 初期化時に実行したい処理
   virtual ReturnCode_t onInitialize()
   {
     if (mylogic.init())
       return RTC::RTC_OK;
     return RTC::RTC_ERROR;
   }
 
   // 周期的に実行したい処理
   virtual ReturnCode_t onExecute(RTC::UniqueId ec_id)
   {
     if (mylogic.do_someting())
       return RTC::RTC_OK;
     RTC::RTC_ERROR;
   }
 
 private:
   MyLogic mylogic;
   // ポート等の宣言
   //   ：
 };

上記はC++での実装例です。 この例では、クラス宣言と実装が一体となってい
ますが、実際にはヘッダファイル (.h) と実装ファイル(.cpp) に分割されてコー
ドが生成されます。 MyLogic クラスのオブジェクトmylogic は、このコンポー
ネントが実際に行うコアロジックが実装されたクラスです。例では、非常に簡
潔にmylogicの関数を呼ぶことでRTCが実装されていますが、実際の実装でも、
コアロジックを予めこの程度簡単に利用できるクラス化しておき、RTC内での呼
び出しは最低限にする方がよいでしょう。

RTCBuilder により同時に生成される Makefile やプロジェクトファイルでこの
コードをコンパイルすることで、実行ファイルと、共有オブジェクト(又は
DLL)が生成される。

** RTCライフサイクル

上述したように、RTCの実装では、予め決められた関数 (コールバック関数) に
処理を記述することで、コンポーネントを作成します。 どのような関数があり、
どういったタイミングで呼ばれるのかを知るためには、RTCの状態遷移すなわち
ライフサイクルを理解する必要があります。下図に、RTCの状態遷移図を示しま
す。

#ref(rtc_state_machine_ja.png,40%,center)
CENTER: ''RTCライフサイクル (UML ステートマシン図)''

コンポーネントは基本的に以下の状態を持つ。 

- 生成状態(Created)
- 活動状態(Alive)
-- 非アクティブ状態 (Inactive)
-- アクティブ状態 (Active)
-- エラー状態 (Error)
- 終了状態

これらの各状態や遷移時には、予め決められた関数 (コールバック関数) がEC
によって呼び出されます。 表に、コールバック関数とそれぞれが呼ばれるタイ
ミングを示します。

| 関数名        | 概要                                       |
| onInitialize  | ライフサイクル初期化時に1度だけ呼ばれる。  |
| onActivated   | アクティブ化する際に1回呼ばれる。          |
| onDeactivated | 非アクティブ化する際に1回呼ばれる。        |
| onExecute     | アクティブ状態にあるとき周期的に呼ばれる。 |
| onStateUpdate | onExecute の後に毎回呼ばれる。             |
| onAborting    | エラー状態に移行する際に1回呼ばれる。      |
| onError       | エラー状態にあるとき周期的に呼ばれる。     |
| onReset       | エラー状態から復帰する際に1回呼ばれる。    |
| onShutdown    | ECの駆動が停止する際に1回呼ばれる。        |
| onStartup     | ECの駆動が開始する際に1回呼ばれる。        |
| onFinalize    | ライフサイクル終了時に1度だけ呼ばれる。    |

