// Title: Service Port (Basic)
// -*- pukiwiki-edit -*-
// 
// @brief How to use Service Port Basic
// @date $Date$
// @author Noriaki Ando <n-ando@aist.go.jp>
// 
// Copyright (C) 2011
//     Noriaki Ando
//     Intelligent Systems Research Institute,
//     National Institute of
//         Advanced Industrial Science and Technology (AIST), Japan
//     All rights reserved.
// 
// $Id$
// 
//* Service Port (Basic)

#contents

//------------------------------------------------------------
** What is service port?

// ロボットシステムをコンポーネント指向で構築するためには、コンポーネント
// 間のデータ通信だけでは十分ではなく、コマンドレベル(あるいは関数レベル)
// のコンポーネント間通信が必要になってきます。例えば、ロボットアームを制
// 御するマニピュレータコンポーネントの場合、手先の位置や速度などは、上位
// のアプリケーションやコンポーネントからデータポートで送られるべきデータ
// です。

When you construct your robot systems according to the component based software development, not only data-centric communication but also command (or function call) based communication between components is necessary.  For example, in case of a manipulator component which controls robot arm, position or velocity of end-effector should be given through data port from application programs of upper layer.

// 一方、ロボットアームの各種設定、座標系の設定、制御パラメータの設定、動
// 作モードの設定、などをデータポートで行うのは適切とは言えず、オブジェク
// ト指向的にいえば、マニピュレータオブジェクトに対して、
// setCoordinationSystem(), setParameter(), setMode(), などの関数が用意さ
// れていて、これらの関数を必要に応じて適切なタイミングで呼ぶのが自然とい
// えます。

On the other hand, according to the object oriented principle,coordination settings, control parameters settings, operation mode settings and other miscellaneous settings for the robot arm should not be performed through data ports .  It is natural that these functionalities are invoked through certain member functions such as setCoordinationSystem(), setParameter() and setMode() of a manipulator object as necessary at the right time.

#ref(serviceport_example_en.png,40%,center)
CENTER: ''An example of service port''

// サービスポートはこのようなコマンドレベルのコンポーネント間のやり取りを
// 行うための仕組みを提供します。

The service port provides a mechanism for a command based (or service based) communication between components.

// 一般にサービスとは、機能的に関連のあるひとまとまりのコマンド (関数、メ
// ソッド、オペレーションなどとも呼ばれます) 群であり、OpenRTM-aistにおい
// ては、この機能を提供する側をサービスプロバイダ(インターフェース)、機能
// を利用する側をサービスコンシューマ(インターフェース)と呼びます。

Generally speaking, a service means a set of commands (it is also called as functions, methods or operations) which are functionally related each other. In the OpenRTM-aist, entities which provide functionality are called a service-provider (interface), and entities which require and use other service entities are called a service consumer (interface).

// なお、UML等の規約においては、サービスプロバイダを Privided Interface,
// またサービスコンシューマを Required Interface などと呼び、それぞれ下図
// のような記号 (ロリポップ (lollipop) 、ソケット (socket) ) で表します。
// これは、一般的な用語および記述法なので覚えておいた方がよいでしょう。呼
// ぶあるいは呼ばれる方向でいえば、呼ばれるものがプロバイダ (Provided
// Interface) であり、呼ぶものがコンシューマ (Required Interface) という見
// 方もできます。

In the UML specifications and its notation rules as well, the service provider is called as ''Provided Interface'' and the service consumer is called as ''Required Interface'', and they are designated as the following notation.

#ref(provider_and_consumer_en.png,40%,center)
CENTER: ''Service provider and consumer''

- Provided Interface: An entity that is called from others and provides services 
- Required Interface: An entity that calls and uses other's services 

// プロバイダおよびコンシューマをまとめてインターフェースまたは、サービス
// インターフェースと呼び、これらサービスインターフェースを持つポートをサー
// ビスポートと呼びます。

The providers and the consumers are referred to collectively as the interfaces or the service interfaces, and the port which has these
service interfaces is called the service port.

** Service port and interfaces

// サービスインターフェースとサービスポートの関係について詳しく説明します。

This section describes the relation between service interfaces and service ports in detail.

#ref(component_port_interface_en.png,40%,center)
CENTER: ''The component, the port and the interface''

// ポートとはコンポーネントに付属し、コンポーネント間の接続の端点となる部
// 分を指します。コンポーネント間の接続とは、コンポーネントに付属するポー
// ト間で接続に関する調停が行われ、何らかの相互作用 (データやコマンドのや
// り取り) が行える状態にすることを意味します。

The port is an end-point, which belongs to a component, for a connection between component.  Connecting two components means that negotiation between ports of components is done and a certain interaction (data-centric or command based) can be performed by it.

// ポート自体はデータやコマンドのやり取りに対して、何の機能も提供しません。
// 実際にコマンドのやり取りを行うのはサービスインターフェース (プロバイダ
// とコンシューマ) になります。一般的にポートには機能的に関連のある任意の
// 数の任意の方向のインターフェースを付加することができます。これにより、
// コマンドのやり取りを一方向だけでなく双方向にすることもできます。

The port does not provide any functionality for data or command communication.  Communication between components is actually performed by service interfaces (service providers and consumers.)  Generally a port can associate functionally related service interfaces of any number and any directions.  This means that not only oneway communication but also bidirectional communication can be performed through it.

// コンシューマとプロバイダは、ポートが接続されたときに、ある条件に基づい
// て接続され、コンシューマからプロバイダの機能を呼び出すことが可能になり
// ます。コンシューマとプロバイダを接続するためには、両者の''型''が同じ、
// または互換性がある必要があります。

A consumer and a provider are connected based on a certain condition, and then a consumer is able to call provider's functions.  In order to connect a consumer and a provider, both ''type'' should be same or compatible.

// 同じ型である、とは同一のインターフェース定義を持つことであり、互換性が
// あるとは、プロバイダのインターフェースがコンシューマのインターフェース
// のサブクラスの一つである、(逆にいえば、コンシューマのインターフェースが
// プロバイダのインターフェースのスーパークラスの一つである)ということにな
// ります。

The same ''type'' means that both interfaces should have same definition, and the compatibility means that the provider's interface is one of the sub-classes of consumer's interface.  In other words, the consumer's interface should be one of the super-classes of the provider's interface.

***The service port

// RTコンポーネントはデータポート同様、任意の数のサービスポートを持つこと
// ができます。また、サービスポートには、任意の種類、数のプロバイダまたは
// コンシューマを付加することができます。

The RT-Component can own any numbers of service ports so that data ports are so.  Moreover, a service port can own any kinds of and any numbers of providers and consumers.

// 以下は、OpenRTM-aistのサンプルコンポーネント MyServiceProvider から抜粋
// したポートとプロバイダの登録のためのコードです。

The following code that is excerpted from MyServiceProvider sample code of OpenRTM-aist shows how to register a port and a provider to the component.

 RTC::ReturnCode_t MyServiceProvider::onInitialize()
 {
   // Set service provider to Ports
   m_MyServicePort.registerProvider("myservice0", "MyService", m_myservice0);
   
   // Set CORBA Service Ports
   addPort(m_MyServicePort);
   
   return RTC::RTC_OK;
 }

// m_MyServicePort.registerProvider() でプロバイダをサービスポートオブジェ
// クト m_MyServicePort に登録しています。第3引数が実体であるプロバイダオ
// ブジェクトです。次に、コンポーネントのフレームワーククラスである
// RTObjectクラスのaddPort() 関数で、ポートをコンポーネントに登録していま
// す。

m_MyServicePort.registerProvider() registers a provider to a service port object m_MyServicePort. The third argument is an entity of the provider object. And next, it is registered to the component by using addPort() function which is RTObject component framework class's member function.

// 同様に、サンプルコンポーネント MyServiceConsumer から抜粋したコードを示します。

Same as above, following shows the excerpted code from MyServiceConsumer sample component.

 RTC::ReturnCode_t MyServiceConsumer::onInitialize()
 {
   // Set service consumers to Ports
   m_MyServicePort.registerConsumer("myservice0", "MyService", m_myservice0);
   
   // Set CORBA Service Ports
   addPort(m_MyServicePort);
 
   return RTC::RTC_OK;
 }

// プロバイダの場合とほとんど同じで、m_MyServicePort.registerConsumer() 関
// 数でコンシューマをポートに登録し、そのポートを addPort() 関数でコンポー
// ネントに登録しています。

Almost same as the provider's case, m_MyServicePort.registerConsumer() function registers a consumer to a port, and the port is registered to the component by addPort function.

// 以上、特に説明もなしに、それぞれ m_myservice0 というオブジェクトが、プ
// ロバイダ、またはコンシューマであるとしてコード例を示しましたが、以下、
// これらのインターフェースがどのように定義され、オブジェクトがどのように
// 実装されるかを説明していきます。

An object m_myservice0 assumed a provider and a consumer without any explanation and they are used in the codes shown above.  How to define these interfaces and how to implement these objects are shown in the following.

***Interface defintion

// インターフェースとは何でしょうか？C++であれば、純粋仮想クラスをインター
// フェースと呼んだりしますし、Javaは言語レベルで interface キーワードが用
// 意されています。

What is the interface?  In C++ language, pure virtual classes are called interface.  In Java language, ''interface'' keyword is used for interface definition.

// OpenRTM-aistには、言語やOSに依存しない、ネットワーク透過であるといった
// 特徴がありますが、これはCORBAと呼ばれる分散オブジェクトミドルウエアを利
// 用することにより実現されています。CORBAは、国際標準化団体OMGで標準化さ
// れている分散オブジェクトミドルウエアで、標準に従って、多くの会社や団体、
// 個人などが多様な実装を提供しています。

The main important features of the OpenRTM-aist are language independence, OS independence and network transparency, and these features are realized by using the distributed object middleware which is called the CORBA.  The CORBA is one of the distributed object middleware which is standardized in a international standardization organization OMG (Object Management Group), and a lot of implementations compliant to the standard are provided by various companies, organizations and individuals.

// OpenRTM-aistでは、インターフェースはIDLと呼ばれるCORBAのインターフェー
// ス定義言語によって定義します。このIDLは言語に依存しないインターフェース
// 定義方法を提供し、またIDLコンパイラと呼ばれるスタブやスケルトンを生成ツー
// ルを利用することで、各種言語に対応したコードが自動的に生成されます。ス
// タブとは、リモートのオブジェクトを呼び出すためのプロキシオブジェクトの
// ためのコードであり、スケルトンとは、プロバイダを実装するためのベースと
// なるコードです。

In the OpenRTM-aist, interfaces are defined by the IDL (Interface Definition Language) that is an interface definition language of CORBA.  The IDL provides a definition scheme independent from any languages, and by using IDL compiler which generates stubs and skeletons, language dependent codes are automatically generated.  The stubs include code of proxy objects which call remote objects, and the skeletons include base classes to implement providers.

// これら自動生成されるコードのおかげで、異なる言語同士の呼び出しもシーム
// レスに行うことができます。例えば、C++で実装されたプロバイダを、Pythonや
// Java等で容易に呼び出すことができるのです。

By the automatically generated codes, the invocation between different languages can be performed seamlessly.  For example, a provider object which is implemented in C++ language can be called from Python and/or Java easily.

// 以下は、OpenRTM-aistのサンプルで使用されているIDL定義です。

An IDL definition used in a OpenRTM-aist's sample is shown in the following.

 module SimpleService {
   typedef sequence<string> EchoList;
   typedef sequence<float> ValueList;
   interface MyService
   {
     string echo(in string msg);
     EchoList get_echo_history();
     void set_value(in float value);
     float get_value();
     ValueList get_value_history();
   };
 };

// module とは C++で言うところの名前空間のようなもので、これによりインター
// フェース名を就職し衝突を防ぐことができます。

The keyword ''module'' is almost same as namespace in C++ language, this qualifies the name of the interface and the collision of name can be avoided.

// C言語等と同様に typedef キーワードがあります。上の例では、sequence と呼
// ばれる動的配列型を定義しています。一つは、string (文字列型) 型のリスト
// として、EchoList 型、もうひとつは float 型のリストとして ValueList 型を
// 定義しています。特に sequence 型は、typedef せずに、定義中で直接使うこ
// とができないので、このように予め typedef しておく必要があります。

You can use ''typedef'' keyword as same as C language.  An array type called ''sequence'' is defined in the above example.  A EchoList type as string list type and a ValueList type as float list type are defined. Especially, since you cannot use sequence types directly, the sequence type should be defined by using typedef before it is used.

// 次に interface で始まる部分が実際のインターフェースの定義になります。
// MyService インターフェースには、5つの関数 (IDLではオペレーションと呼び
// ます) が定義されています。ほとんどは、C言語やJavaなどと同じような定義で
// すが、IDLでは引数が入力であるか出力であるかを明確にするために、引数宣言
// の前に、''in'', ''out'' または ''inout'' の修飾子が付きます。

Next, the part which starts with ''interface'' keyword is the actual interface definition.  The MyService interface owns five functions (in IDL they are called ''operations'') in it.  Syntax is almost same as C language and Java language, but one of the specifiers ''in'', ''out'' or ''inout'' is put before each argument to specify whether the argument is used as input, output or both.

***IDL compilation

// 図に、IDL定義からIDLコンパイル、プロバイダの実装およびスタブの利用の流
// れを示します。

The following figure shows the flow of IDL definition, IDL compilation, implementation of provider and use of stub.

#ref(idlcompile_stub_skel_en.png,40%,center)
CENTER: ''IDL compilation and stub and skeleton''

// 定義されたIDLをIDLコンパイラに与えてコンパイルを行うと、通常スタブとス
// ケルトン (またはサーバとクライアントという呼び方をする場合もある) のた
// めのコードが生成されます。

Giving defined IDL to a IDL compiler and compiling it, stubs and skeletons (these are sometimes called servers and clients) are generated.

// クライアント、すなわちサービスを利用する側は、スタブコードをインクルー
// ドするなどして、スタブとしてい定義されているプロキシ(代理)オブジェクト
// を利用して、リモートにある、サーバの機能にアクセスします。以下にC++での
// コード例を示します。

A client, which is using service, accesses to the functions of server on a remote node through proxy object defined as stub that is included in the stub code.  An example in C++ language is shown in the following code.

 MyService_var mysvobj = <something to get remote object reference>
 Retval retval = mysvobj->myoperation(argument);

// MyService_var というのが、プロキシオブジェクトのための宣言です。
// mysvobjにリモートオブジェクトの参照を何らかの形で代入すると、その下で行
// われている myoperation() 関数の呼び出しは、実際にはリモートに存在するオ
// ブジェクトにおいて行われます。このMyService_var クラスが定義されている
// のがスタブにあたります。

A line starting with MyService_var is declaration for a proxy object. After substituting a remote object reference into the ''mysvobj'' variable, the invocation of myoperation() function performs remote object function call actually.  The MyService_var class is the stub defined in the stub code.

// 一方、上記の方法によって実際に呼ばれるサーバ側のオブジェクトは、以下の
// ようにスケルトンクラスを継承して以下のように実装されます。

On the other hand, the server side object which is called by the above method is implemented by inheriting a skeleton class as follows.

 class MyServiceSVC_impl
   : public virtual MyService,
     public virtual PortableServer::RefCountServantBase
 {
 public:
    MyServiceSVC_impl() {};
    virtual ~MyServiceSVC_impl() {};
    Retval myoperation(ArgType argument)
    {
      return do_ something(argument);
    }
 };

// さらに、ここで定義されたサーバントクラスをインスタンス化し、CORBAオブジェ
// クトとしてアクティベートすることで、リモートからオペレーションを呼び出
// すことができます。

And, instantiating a servant class defined above, and activating it as a CORBA object, operations can be called from remote node.

 // some spells to startup ORB of CORBA
 MyServiceSVC_impl mysvc;
 POA->activate_object(id, mysvc);

// IDLを定義して、コンパイルすることで、分散オブジェクトを定義し利用するの
// に必要な大半のコードが自動的に生成されます。ただし、上記の「何らかの方
// 法でリモートオブジェクトの参照を取得」したり、「CORBAのORBを起動するた
// めのいろいろなおまじない」といったものは、CORBAを直接利用する場合には依
// 然としてコーディングする必要がある部分であり、これらはCORBAを利用するう
// えでも理解が難しかったり、煩雑な作業が必要となる部分です。

Defining and compiling IDL, most of codes required to define and use distributed objects are generated automatically.  However, ''something to get remote object reference'' and ''some spells to startup ORB of CORBA'' are still required in the actual coding, and these are one of difficult and complicated things in use of CORBA.

// しかしながら、OpenRTM-aistを利用すれば、こうしたCORBAの様々な呼び出しの
// 大半は隠蔽され、実装者はクライアントの呼び出し、サーバントの実装にのみ
// 集中することができます。以下では、サーバントを実装しプロバイダとしてコ
// ンポーネントに登録する方法、コンシューマとしてプロバイダを利用する方法
// について詳しく見ていきます。

Using OpenRTM-aist, however, most of these CORBA's native function calls are hidden, and developers can concentrate only to servants' implementation, and calling servers from clients.  In the following, how to implement servants and register it to the component and how to use providers from the consumers are described in details.

** Implementation

// サービスポートの実装に当たっては、RTCBuilderを利用するのが便利です。自
// 分でサービスポート、プロバイダおよびコンシューマを実装することもできま
// すが、CORBAやIDLコンパイラに精通している必要がありますし、Makefileやコー
// ドの様々な部分を書き換える必要がありますのであまりお勧めできません。

It is convenient to use RTCBuilder in implementing a service port.You can implement service ports, providers and consumers by yourself. But a detailed knowledge of CORBA, IDL compiler is required, and Makefile and some parts of source code have to be modified. It is not recommended.

// RTCBuilderの詳細な使い方は、RTCBuilderのマニュアルを参照してください。

See the manual of RTCBuilder for the detailed usage of RTCBuilder.

*** IDL Definition

// サービスポートを利用するには、利用するインターフェースを予めIDLで定義す
// るか、既存のIDLファイルを適当なディレクトリに配置しておく必要があります。

In order to use service ports, you have to define interfaces in IDL files or use pre-defined IDL files, and have to put them into appropriate directory.

// IDLの定義方法については、ここでは詳細は述べませんが、おおよそ以下のよう
// なフォーマットで定義することができ、C言語やJavaに慣れた読者であれば、比
// 較的容易に定義できるでしょう。

Detailed IDL definition rules are not described here, but it can be defined roughly as follows.  Developers who are familiar with C or Java languages would easily understand it.

 // Module can be defined for namespace.
 // Using a module definition positively is recommended.
 module <module name>
 {
   // struct could be defined as follows
   struct MyStruct // structure name
   {
     short x; // only short and long integer types are available
     short y;
     long  a;
     long  b;
     double dval; // only float and double floating point types are available
     float fval;
     string strval; // string type is available for character string
   };
 
   // dynamic sequence type should be typedefed previously
   typedef sequence<double> DvalueList;
   typedef sequence<MyStruct> MyStructList; // sequence of any struct allowed
 
   // interface definition
   interface MyInterface // interface name
   {
     void op1(); // no return value, not arguments
 
     // NG: the following definition is error, because uppercase and lowercase are not distinguished
     // short op2(in MuStruct mystruct);
     short op2(in MyStruct mydata); // direction is specified {in, out, inout}
 
     oneway void op3(); // oneway keyword can be used for only operations with no return
 
     void op4(in short inshort, out short outshort, inout short ioshort);
 
     void op5(MyInterface myif); // MyInterface itself can be used for arguments
   };
 
   // one or more interfaces can be defined one IDL file
   interface YourInterface
   {
     void op1();
   };
 };


*** Designing by using RTCBuilder

// 上のようにIDLで定義したインターフェースを、これから開発するRTコンポーネ
// ントのサービスポートのプロバイダ、もしくはコンシューマとして用いるため
// には、コンポーネントのコードジェネレータである RTCBuilder でサービスポー
// トを設計し、その際にこのIDL定義を与えてやる必要があります。

In order to use interfaces defined as mentioned above for service ports' providers and consumers in your new RT-Component, IDL definition should be given to RTCBuilder tool which can be used to design RT-Components.

// RTCBuilder の新規プロジェクトを作成し、パースペクティブを開きます。各種
// プロファイル(コンポーネントの名称やカテゴリ名)等、必要な設定を行った後、
// サービスポートタブを開くと、次のような画面が現れます。

Create a new project of RTCBuilder and open perspective of RTCBuilder. After setting various required profiles including component's name and category, open service port's tab, you can see the following editor view.

#ref(rtcbuilder_serviceport_tab1_en.png,40%,center)
CENTER: ''Service port's design tab.''

// まず、''Add Port'' ボタンを押しサービスポートを一つ追加します。そうする
// と、sv_name というサービスポートが一つ追加され、下のBuildViewのコンポー
// ネントの箱に、小さな正方形のポートが一つ追加されます。RTCBuilderのエディ
// タ左のポートリストのsv_nameをクリックすると、右側に''RT-Component
// Service Port Profile''が表示されるので、ポート名を適当な名前 (ここでは
// ''MyServiceProviderPort'') に変更します。

At first, click ''Add Port'' button and add a service port to the RT-Component.  Then a service port named sv_name is added, and a small rectangle signifying a port is added on a component's larger rectangle in the build view that is usually located below.  Click sv_name in port list in the left side of the editor, then ''RT-Component Service Port Profile'' will appear on the right side.  Please modify it to an appropriate name (here it is set as ''MyServiceProviderPort'').

#ref(rtcbuilder_serviceport_tab2_en.png,40%,center)
CENTER: ''Adding a service port''

// エディタ左のポートリストの MyServiceProviderPort をクリックし、''Add
// Interface''ボタンをクリックすると、MyServiceProviderPort にインターフェー
// ス ''if_name'' が一つ追加されますので、先ほどと同様にエディタ左
// の''if_name''をクリックし、''RT-Component Service Port Interface
// Profile''上で''if_name''を適当な名前 (ここではMyServiceProvider) に変更
// します。下のBuildeViewでは、正方形のポートにロリポップが追加され、プロ
// バイダ (Provided Interface) がポートに付加されたことが視覚的に分かりま
// す。

Click MyServiceProviderPort in the list at the left side of the editor and then click ''Add Interface'' button.  You will find an interface ''if_name'' is added under the MyServiceProviderPort.  As well as former step, click ''if_name'' at the left side of the editor, then rename ''if_name'' to an appropriate name (here it is set as ''Provided Interface'') on the ''RT-Component Service Port Interface Profile''.


#ref(rtcbuilder_serviceport_tab3_en.png,40%,center)
CENTER: ''Adding a service interface (provider)''

// エディタ右側の Interface Profile では、インターフェースのプロファイルを
// 設定します。例えば''方向''のドロップダウンリストでは、対象のインター
// フェースがプロバイダ (Provided) かコンシューマ (Required) かを指定しま
// す。

You can set interface profile in the Interface Profile pane at the right side of the editor. For example, you can specify the target interface as a provider (provided interface) or a consumer (required interface) in the ''Direction'' drop-down list.


#ref(rtcbuilder_direction_ddown_en.png,100%,center)
CENTER: ''Setting direction of a service interface''

// ここではプロバイダを追加しようとしているので、Provided のままにしま
// す。このほか、インスタンス名、変数名なども指定できますが、必須ではあり
// ません。インスタンス名は、接続時にプロバイダとコンシューマのインスタン
// ス名が同じなら、対応関係を指定しなくてもポートの接続を自動的に行う場合
// に利用されます。

Since we are trying to add a provider interface now, keep it ''Provided.''  Additionally a intance name, a variable name can be specified, but thease are not mandatory parameters. The instance name is used as a matching key when service ports are connected without detailed interface pair settings.

#ref(serviceif_autoconnection_en.png,40%,center)
CENTER: ''Instance name of service interface, and automatic pairing.''

// ただし、インスタンス名が異なっていても、接続時に任意のインターフェース
// 同士を接続できるので、入力は必須ではありません。また、変数名はコードを
// 生成した際にプロバイダオブジェクトを代入する変数名を指定するための項目
// ですが、これもインターフェース名から自動的に生成されるので、入力は任意
// です。

However, the instance name is not a must, because even if instance names are different between provider and consumer, you can specify interface pairs at connection time.  Although the variable name is used to specify the name of variable which is substituted by a provider object in the generated source code, it is not mandatory since these are also generated automatically from interface name.

// 次にIDLの指定と、インターフェース型の指定を行います。上で定義したような
// IDLを適当なディレクトリに配置し、IDLファイル指定ボックス横の Browse ボ
// タンを押し、対象となるIDLを指定します。すると、指定されたIDLで定義され
// たインターフェースが、その下のインターフェース型のドロップダウンリスト
// に現れます。このドロップダウンリストで、このポートに付加したインター
// フェース名を選択します。IDLファイルに文法エラーなどがある場合には、ドロッ
// プダウンリストに希望するインターフェースが現れません。再度IDLファイルの
// 定義をチェックしてください。

Next, specify interface type and its IDL (Interface Definition Language) file.  Put IDL files to proper location, and click ''Browse'' button at the side of IDL file name input form, and specify the IDL from the dialogue window.  After that, the interfaces defined in the IDL file will appear in the interface type dropdown list. Select interface to be owned by the port from the dropdown list.  If IDL file includes some errors such as syntax error, expected interface names might not appear.  In such case, please check the specified IDL file again.



#ref(rtcbuilder_interfacetype_ddwon_en.png,100%,center)
CENTER: ''Selecting interface type''

// なお、上述の''方向''ドロップダウンリストで ''Required''を指定すると、こ
// のインターフェースはコンシューマになります。以下は別のコンポーネント
// ''MyServiceConsumer'' のサービスポートとインターフェースの設定画面の例
// です。

Moreover, if the ''Required'' is specified in the ''Direction'' dropdown list, the interface will be a consumer.  The following figure shows a service port and interfaces setting page of another ''MyServiceConsumer'' component.


#ref(rtcbuilder_serviceport_tab4_en.png,40%,center)
CENTER: ''Adding service interface (consumer)''

// エディタ下の BuildView においてポートにソケットが追加されて、コンシュー
// マ (Required interface) がポートに付加されたことが視覚的に分かります。

Finally you will find visually that consumer (Required interface) is added to the port in the BuildView pane under the editor.

// *** プロバイダの実装
*** Implementing Provider

// プロバイダというのは文字通り、サービスをプロバイド(提供)するためのイン
// ターフェースです。したがって、IDLで定義したインターフェースを持つサー
// ビスの中身を実装する必要があります。

The Provider is literally a interface to provide some service. Therefore, the service that is the actual functionality of the provider interface has to be implemented.

// プロバイダインターフェースを持つコンポーネントをRTCBuilderで設計した場
// 合、コード生成を行うと、コンポーネントのソースのひな形とともに、例えば
// C++の場合には、<サービスインターフェース名>SVC_impl.cpp と <サービスイ
// ンターフェース名>SVC_impl.h という、プロバイダの実装コードのひな形も生
// 成されます。

In case of designing a component with service provider interfaces by RTCBuilder, for example in C++ language, additional provider's implementation source code such as <service interface name>SVC_impl.cpp and <service interface name>SVC_impl.h will be generated with other component template source code.

#ref(rtcbuilder_svcimpl_cxxsrc_en.png,100%,center)
CENTER: ''Service provider implementation files (C++,Python,Java)''

以下に、各言語で生成されるプロバイダの実装のひな形コードのファイル名を
示します。

Provider's implementation template code file names for each language are shown in the following.

|>|CENTER: ''Generated template code files'' |
| ''C++''    | <interface name>SVC_impl.cpp &br; <interface name>SVC_impl.h |
| ''Python'' | <interface name>_idl_example.py |
| ''Java''   | <interface name>SVC_impl.java |


#ref(rtcbuilder_svcimpl_pysrc_en.png,100%,center)
CENTER: ''Implementation file for service provider (Python)''

#ref(rtcbuilder_svcimpl_javasrc_en.png,100%,center)
CENTER: ''Implementation file for service provider (Java)''

// これらの実装のひな形には、IDLで定義されたインターフェースに相当するクラ
// スがあらかじめ定義されています。

A class associated to the interface defined in IDL is already declared
in these implementation templates.

// ここでは、C++での実装方法を例にとり、IDLで定義されたオペレーションのい
// くつかを実装していきます。

Here, as an example, some operations defined in IDL will be implemented in C++ language.


// ****echo()関数の実装
****echo() operation implementation

// はじめに、echo() メンバ関数を見てみます。

Let's see echo() member function at first.

 /*
  * Methods corresponding to IDL attributes and operations
  */
 char* MyServiceSVC_impl::echo(const char* msg)
 {
   // Please insert your code here and remove the following warning pragma
 #ifndef WIN32
   #warning "Code missing in function <char* MyServiceSVC_impl::echo(const char* msg)>"
 #endif
   return 0;
 }

// #warning プリプロセッサディレクティブがありますが、これはgccでコンパイ
// ルした際にこの関数が実装されていないことを警告するためのものですので、
// #ifndefごと削除します。

You can find the #warning preprocessor directive.  Since an error arises at the compile time if this function is not implemented, delete them including #ifndef directive.

 char* MyServiceSVC_impl::echo(const char* msg)
 {
   return msg;
 }

// また、この関数は、echo() 関数の引数に与えられた文字列を、単に呼び出し側
// に返すだけの機能を提供するとします。したがって、以下のように実装すれば
// よいように思えます。

Now we assume that this function echo() just return given string in argument to the caller. Therefore, the following implementation seems apparently normal.

 char* MyServiceSVC_impl::echo(const char* msg)
 {
   return msg;
 }

// しかし、これはコンパイル時にエラーになります。const char* を char* に渡
// しているためです。また、CORBA のオブジェクトの実装方法としても間違って
// います。CORBAでは、return で返されるオブジェクトは、ORB (Object
// Request Broker, リモートオブジェクトの呼び出し部分を司る部分、CORBAのコ
// ア) によって解体されるというルールがあるためです。(return時にはオブジェ
// クトの所有権を放棄する、とも言います。)

However, this will be error when it is compiled. Because the const char* variable is returned to char* type.  Addingly it is also incorrect in the CORBA implementation rules.  Because CORBA has a rule that the ownership of the returned object has to be released and ORB destructs after that.

// したがって、return には、別途領域を確保し、msg の内容をコピーした文字列
// を返す必要があります。これに従えば、以下のように実装すればよいように思
// うかもしれません。

Therefore, in order to return objects, you have to allocate memory and copy the contents of msg and return it. According to this rule, the following implementation seems correct.

 char* MyServiceSVC_impl::echo(const char* msg)
 {
   char* msgcopy;
   msgcopy = malloc(strlen(msg));
   strncpy(msgcopy, msg, strlen(msg));
   return msgcopy;
 }

// ここでは、mallocで領域を確保していますが、ORBはfreeで領域を解体するのか、
// deleteで解体するのかはわかりません。実は、CORBAではオブジェクト(構造体
// や配列、またその複合型等も含む)や文字列を扱うための方法が別途定められて
// いて、それに従って関数の引数を受け取ったり、返したりする必要があるので
// す。

Here, although memory is allocated by using malloc, it is uncertain whether the area would be released by free() or delete().  Actually CORBA provides methods to allocate and/or destruct objects (including structure, array and complex types), and developers have to receive argument and return value according to the rules.

// CORBAで定められた方法に従うと、echo()関数は以下のように実装する必要
// があります。

According to the CORBA rule, the echo() function should be implemented as follows.

 char* MyServiceSVC_impl::echo(const char* msg)
 {
   CORBA::String_var msgcopy = CORBA::string_dup(msg);
   return msgcopy._retn();
 }

// 関数内の1行目では、CORBAの文字列クラスCORBA::String のスマートポインタ
// である CORBA::String_var 型を宣言しています。String_var 型はいわゆる所
// 有権を管理するためのスマートポインタでSTLのauto_ptrに似ています。

In the first line of the function, CORBA::String_var which is a kind of smart pointer for CORBA's string class CORBA::String is declared. String_var, which is similar to auto_ptr of STL, is a smart pointer to manage ownership of objects.

 CORBA::String_var msgcopy = CORBA::string_dup(msg);

// この String_var 型の変数 msgcopy に引数の msg に格納されている文字列を
// コピーしているのが CORBA::string_dup() 関数です。この関数では引数に与え
// られた文字列を格納するのに十分なメモリ領域を確保し、その領域に引数の文
// 字列をコピーしています。

This CORBA::string_dup() function copies the character string stored in msg variable to the variable msgcopy which is a String_var type variable.  In this function, sufficient memory space for given characters are allocated and these are copied to the area.

// 次の行では、return で呼び出し元に msgcopy 内の文字列を返しつつ、オブジェ
// クトの所有権を放棄、return 側に所有権を移譲しています。下図に示すように
// ORB では、return で返された文字列を、ネットワーク上の呼び出し元に送信し
// てから、文字列オブジェクトを解放します。

At the next line, character string in msgcopy is returned to caller and its ownership is released and is transferred to caller.  As shown in the following figure, ORB destructs string object after it is transferred to the caller on the network.


#ref(serviceport_orb_and_provider_en.png,50%,center)
CENTER: ''Relation among ORB, operation call and memory management.''

// このルールをよく理解すると、msgcopy オブジェクトが echo() 関数内で使用
// されていないことから、echo() 関数の実装は最終的には以下のようにも書くこ
// ともできます。

According to this rule, since msgcopy object is used only for return value in the function, the implementation of the echo() function can be written as follows.

 char* MyServiceSVC_impl::echo(const char* msg)
 {
   return CORBA::string_dup(msg);
 }

// CORBA::string_dup() 関数で文字列領域の確保と内容のコピーを行ったうえで、
// その所有権を直に呼び出し元に与えていることになります。

This means that CORBA::string_dup() function allocates memory for string characters, copies it to there and transfers its ownership to caller.

// このように、サービスプロバイダは CORBA のオブジェクトですので、その実装
// 方法は通常の C++ の実装とは少し違ったやり方で行う必要があります。特に、関
// 数の引数および返り値の受け渡し規則は、少し複雑なように見えます。ただし、
// 上記のように、オブジェクトの所有権という考え方を念頭において考えると、
// 引数をどのように受け取るべきなのか、あるいは返り値をどのように返すべき
// なのかが自ずと明らかになります。詳細については、Appendixや他のCORBAの参
// 考書等を参考にしてください。

In this manner, since a service provider is a CORBA object, its implementation have to be performed as a little different way from the normal C++ style programming.  Especially the rule for argument and return value for operations seems difficult to understand.  However, as mentioned above, if you are keeping the ownership handling of objects in your mind, you can easily understand how to receive arguments and how to return object.  For details, please refer to the reference book of Appendix or other CORBA etc.

// ****set_value(), get_value() と get_value_history()
****set_value(), get_value() and get_value_history()

// 次は、set_value() 関数, get_value() 関数および get_value_list() 関数を
// 同時に実装していきます。これらの関数は、set_value() で設定されたfloat型
// の値を保存しておき、get_value()でその値を返すという単純なものです。また、
// get_value_history() では、今までにセットされた値の履歴を保存しておき、
// 履歴をリストとして返すというものです。

Next, set_value(), get_value() and get_value_list() functions will be implemented simultaneously.  These functions work as follows. set_value() sets a float type value and stores a variable, get_value() returns the stored value, and get_value_history() returns history list which is recorded past set values.

// ]まず、値を保存しておく変数を用意します。現在の値はMyServiceSVC_implクラ
// ]スにCORBA::Float型のprivateメンバーとして用意します。一方、
// ]get_value_history() では、戻り値にSimpleService::ValueList というCORBA
// ]のシーケンス型が使われているので、これをメンバー変数として持つようにし
// ]ます。これらの変数宣言を MyServiceSVC_impl.h の MyServiceSVC_impl クラ
// ]ス定義の最後の方に以下のように追加します。

At first, a variable to store current value is needed.  The current value is declared as a CORBA::Float type private member of MyServiceSVC_impl class.  On the other hand, in the get_value_history() function, since a CORBA sequence type SimpleService::ValueList is used for return value, same type variable should be owned as a member variable.  These variable declarations are added to the end of MyServiceSVC_impl class definition in MyServiceSVC_impl.h.

 class MyServiceSVC_impl
   : public virtual POA_SimpleService::MyService,
    public virtual PortableServer::RefCountServantBase
 {
   : (*snip*)
 private:
   CORBA::Float m_value; // add this line
   SimpleService::ValueList m_valueList; // add this line
   };

// 変数の初期化も忘れずに行います。MyServiceSVC_impl.cpp のコンストラクタ
// で、m_value は 0.0に、m_valueList は長さ0に初期化しておきます。

Remember to initialize variable. In the constructor in MyServiceSVC_impl.cpp, m_value is set to 0.0 and the length of m_valueList is set to 0.

 MyServiceSVC_impl::MyServiceSVC_impl()
 : m_value(0.0), m_valueList(0)
 {
   // Please add extra constructor code here.
 }

// 次に、set_value() 関数を実装します。引数に与えられた数値をメンバ変数
// m_value に代入するとともに、m_valueListにも追加します。CORBAのシーケン
// ス型は、動的配列型で、[]オペレータとともに、length(),
// length(CORBA::ULong) の関数を利用することができます。length() 関数は、現
// 在の配列の長さを返し、length(CORBA::ULong) 関数は現在の配列の長さを設定
// します。実装は以下のようになります。

Next, set_value() function is implemented. Set a value from the argument to a member variable m_value, and add it also to m_valueList. CORBA's sequence type is a kind of dynamic array type, and [] (array) operator, length() and length(CORBA::ULong) operators are available. length() returns current length of the array, and lenght(CORBA::ULong) set length of the array.  The function can be implemented as follows.

 void MyServiceSVC_impl::set_value(CORBA::Float value)
   throw (CORBA::SystemException)
 {
   m_value = value; // 現在値
 
   CORBA::ULong len(m_valueList.length()); // Getting length of the array
   m_valueList.length(len + 1); // Increment length of the array
   m_valueList[len] = value; // Adding a value to the end of the array
  
   return;
 }

// echo() 関数とは異なり、CORBA::Long 型はC++のlong intと等価で、オブジェ
// クトの所有権、領域確保や廃棄等は考える必要はありません。したがって、上
// のように単純な代入で構いません。また、配列型は、2種類の length() 関数と
// []オペレータを利用して、配列の長さを1つ増やして最後尾に引数の値を代入し
// ています。なお、OpenRTM-aistでは、CORBAのシーケンス型をSTLのvectorに近
// い形で利用するための関数テンプレートを提供しており、それを使うと、

Differing from the argument of the echo() function, since CORBA::Long type is equivalent of long int type, you do not need to consider ownership, allocation and destruction of objects.  Therefore, simple assignment above is allowed.  By using two types of length() function and [] array operator of the sequence type variable, length of the variable is incremented and a value is added to the tail of the array. OpenRTM-aist provides some function templates which enables CORBA sequence type to be used like STL vector container, and the above code can be implemented as follows.

 void MyServiceSVC_impl::set_value(CORBA::Float value)
   throw (CORBA::SystemException)
 {
   m_value = value; // Current value
   CORBA_SeqUitl::push_back(m_valueList, value);
 
   return;
 }

// のように書くことができます。CORBA_SeqUtil.h では、 for_each(), find(),
// push_back(), insert(), front(), back(), erase(), clear() といった関数が
// 定義されています。

In the CORBA_SeqUtil.h, for_each(), find(), push_back(), insert(), front(), back(), erase() and clear() functions are defined.

// get_value() は以下のようになります。

get_value() can be implemented as follows.

 CORBA::Float MyServiceSVC_impl::get_value()
   throw (CORBA::SystemException)
 {
   return m_value;
 }

// 保存された値を return で呼び出し元に返すだけです。ここでも、先ほどの
// echo() の例とは異なり、CORBA::Float がプリミティブ型なので所有権等を考
// 慮する必要はありません。

This function only returns the stored value.  Differing from echo() function, since CORBA::Float is primitive type, you do not need to consider ownership, and so on.

// 最後に、get_value_history() の実装を見ていきます。値の履歴が格納された
// m_valueListを返せばいいだけのように思えますが、先ほどの述べた所有権と領
// 域の解放の問題があるため、以下のように実装する必要があります。

Finally, let's see an implementation of the get_value_history() function.  Although it seems simply returning m_valueList is enough, ownership, because of the problems about allocation and destruction, the implementation should be as follows.

 SimpleService::ValueList* MyServiceSVC_impl::get_value_history()
   throw (CORBA::SystemException)
 {
   SimpleService::ValueList_var vl;
   vl = new SimpleService::ValueList(m_valueList);
   return vl._retn();
 }

// 関数内1行目では、シーケンス型オブジェクトのためのスマートポインタである、
// SimpleService::valueList_var 型の変数を宣言しています。さらに次の行で、
// このスマートポインタに対して、コピーコンストラクタを呼び出してそのポイ
// ンタを代入しています。これにより、領域の確保と、値のコピーが同時に行わ
// れます。最後に、vl._retn() で、vl が保持しているシーケンス型のオブジェ
// クトの所有権を放棄して、return側にオブジェクトを渡しています。

At the first line of the function, SimpleService::ValeList_var type which is a smart pointer type of sequence object is declared.  At the next line, calling the copy-constructor, its pointer is assigned to the declared smart pointer.  It performs allocation of memory and copy of the value simultaneously.  Finally, vl._retn() releases the ownership of the sequence type object owned by vl variable, and object is passed as return variable.

// そして、vl は関数内で使用されていないので、以下のように書くこともできます。

And, since the variable vl is not used in the function, it can be coded as follows.

 SimpleService::ValueList* MyServiceSVC_impl::get_value_history()
   throw (CORBA::SystemException)
 {
   return new SimpleService::ValueList(m_valueList);
 }


// 以上、プロバイダの実装についてみてきましたが、プロバイダがいわゆる
// CORBAオブジェクトであるので、使用する型、変数の受け渡しの仕方など、
// CORBAのルールに従って実装しなければなりません。はじめは煩わしく感じるか
// もしれませんが、プリミティブ型については従来通りの実装、複雑なオブジェ
// クトについてはメモリの確保と解放がどこで行われるか、所有権はどちらにあ
// るかを理解すると、どのように実装するべきなのか理解できると思います。

What you just read is the outline of implementation of service ports. Since a provider is a kind of CORBA object, they should be implemented according to the CORBA way such as types to be used, the way of argument passing.  Although you might feel it a little troublesome at first, you can use primitive types as conventionally, and you can easily understand how to use other complex types if you understand ownership of variables and memory allocation and destruction.

***Using Consumers

// コンシューマでは、上で実装したサービスプロバイダを呼び出し、その機能を
// 利用することになります。コンシューマを持つコンポーネントのひな形コード
// をRTCBuilderで生成した場合には、プロバイダの場合とは異なり特別なファイルは生
// 成されません。

Consumers call service providers which are implemented as presented above and use their functionality.  When RTCBuilder generates template source code of component which has consumers, other special files are not created, unlike component which has providers.

// その代わり、コンポーネントのヘッダに以下のようなプロバイダのプレースホ
// ルダであるコンシューマオブジェクトが宣言されます。

In stead of generating files, the following consumer object as a place holder will be declared in the header of component source code.


      : (*snip*)
   // Consumer declaration
   // <rtc-template block="consumer_declare">
   /*!
    */
   RTC::CorbaConsumer<SimpleService::MyService> m_MyServiceConsumer;
 
   // </rtc-template>
 
  private:
      : (*snip*)

// これは、RTC::CorbaConsumer クラステンプレートに型引数
// SimpleService::MyService を与えて、MyService 型のコンシューマを宣言して
// いることになります。また、実装ファイルの方では、onInitialize() 関数にお
// いて、コンシューマのポートへの登録と、ポートのコンポーネントへの登録が
// 行われていることが確認できます。

This means that type argument SimpleService::MyService is given to the class template of RTC::CorbaConsumer, and MyService type consumer is declared.  You can find that they are registered to a port in the onInitialize() function and the port is also registered to the component in the implementation file.

 RTC::ReturnCode_t MyServiceConsumer::onInitialize()
 {
   : (*snip*)   
  // Set service consumers to Ports
   m_MyServiceConsumerPortPort.registerConsumer("MyServiceConsumer",
                                                "SimpleService::MyService",
                                                m_MyServiceConsumer);
  
   // Set CORBA Service Ports
   addPort(m_MyServiceConsumerPortPort);
   // </rtc-template>
 
   return RTC::RTC_OK;
 }
 

// ヘッダで宣言されていた m_MyServiceConsumer 変数が、registerConsumer()
// メンバ関数によってポートに登録されていることが分かります。第1引数では、
// このコンシューマの「インスタンス変数」が、第2引数ではコンシューマの「イ
// ンターフェース型」が、そして第3引数ではコンシューマのインスタンスである
// m_MyServiceConsumer 変数がそれぞれ与えられています。これによって、コン
// シューマがインスタンス名、型名ともにポートに関連付けられていることにな
// ります。

You can see that a variable m_MyServiceConsumer which is declared in the header is registered to a port by the registerConsumer() member function.  An instance variable of the consumer as the first argument, an interface type of the consumer as the second argument, and m_MyServiceConsumer variable of a instance of the consumer as the third argument are given to the function respectively.  According to this function call, the service consumer is associated with a port with instance name and type name.

// コンシューマ m_MyServiceConsumer は上でも述べたように、プロバイダのプレー
// スホルダになっています。C++では、オブジェクトへのポインタのように扱うこ
// とができます。

As above mentioned, the consumer m_MyServiceConsumer is a place holder of a provider object. In C++ language it can be handled as a pointer.

MyService インターフェースでは、string 型 (CORBAのstring型) 引数を一つ
取る echo() オペレーションが定義されていました。したがって、例えば以下
のように echo() 関数を呼び出すことができます。

 m_MyServiceConsumer->echo("Hello World");

// C++では上のようにポインタ、JavaやPythonでは参照のように、オペレーション
// を呼び出すことができるのです。

Operations can be called by it like a pointer in C++ language, and a reference in Java and Python languages.

// さて、ここで勘の良い方は、ポインタまたは参照の指す先は一体どうなってい
// るんだとお思いでしょう。C++等でも、例えば以下のようなコードは
// segmentation fault で即座に落ちます。

And now, readers who have enough experience in C++ language might be wondering what is the entity of the pointer and the reference.  In C++ language, the following code is aborted immediately by segmentation fault.

 class A {
 public:
   const char* echo(const char* msg) {
     std::cout << msg << std::endl;
     return msg;
   }
 };
 
 int main (void) {
   A* a;
   a->echo("Hello World!!");
 }

// a はnullポインタですので、何もオブジェクトを指していません。これと同様
// に、上の m_MyServiceConsumer も、コンポーネントの起動直後には、いかなる
// オブジェクトも指していませんので、当然オペレーションを呼び出すことがで
// きません。上の class A の場合では、

The "a" is a null-pointer, and it points nothing.  In the same way, since m_MyServiceConsumer can be state that does not point any object, it cannot call any operations.  In the above example, variable "a" can be a valid pointer if a new object is created and is assigned to the pointer as the following.

 int main (void) {
   A* a;
   a = new A();
   a->echo("Hello World!!");
 }

// オブジェクトをnewで生成して、変数 a に代入してあげれば a はその時点であ
// るオブジェクトを指し示す正当なポインタですので、class Aのメンバ関数であ
// る echo() を呼ぶことができます。

Therefore, now variable "a" can call the "echo()" function which is a member of class A.

// しかしながら、コンポーネントないのコンシューマが呼び出したいのは、ネッ
// トワーク上のどこかにあるオブジェクトのオペレーションです。したがって、
// m_MyServiceConsumer が指し示すのはリモートオブジェクトの参照 (CORBAオブ
// ジェクト参照(リファレンス)) です。

However, consumer in the component would call a operation of the remote object which is located somewhere on the network.  In other words, m_MyServiceConsumer points a reference (CORBA's object reference) to a remote object.

// 実は下図に示すように、コンシューマはそのポートがプロバイダを持つポート
// と接続されるときに、対応するオブジェクト参照を受け取ります。接続により
// コンシューマは正当なオブジェクトを指すことになり、こうして初めてオペレー
// ションを呼び出すことができるのです。

As shown in the following figure, a consumer receives an object reference when it is connected to the other port which has provider. After the connection established, since the consumer has a valid object reference, it can call operations in the remote object.

#ref(serviceport_connection_and_reference_en.png,40%,center)
CENTER: ''Connecting service ports and object reference''

// 接続後は(相手のポートに適当なプロバイダが存在すれば)コンシューマのオペ
// レーションを呼び出すことができますが、接続していない場合、または有効な
// 参照がセットされていない場合は、コンシューマオブジェクトは例外を投げま
// す。そして、コンシューマを利用する場合、いつ接続が行われるか、またいつ
// 接続が切断されるかは分かりませんので、常にこの例外を捕捉して適切に処理
// する必要があります。

After connection established, the consumer can call operations if an appropriate provider exists in the other port.  The consumer will throw exceptions if the connection is not established or valid object reference is not set.  Since you cannot know when connection is established or is destructed, always you have to catch exceptions from consumers and handle them adequately.

 try
 {
   m_MyServiceConsumer->echo("Hello World!!");
 }
 catch (CORBA::SystemException &e)
 {
   // some logic when exception is caught
      std::cout << "Port is not connected" << std::endl;
 }
 catch (...)
 {
   // Other exceptions
 }

// なお、onExecute() メンバ関数内で例外が発生し、関数内部で捕捉されなかっ
// た場合、RTCはエラー状態へ遷移します。

If an exception is thrown from the onExecute() member function, and the exception is not caught, RTC will go to error state.

// 以上を踏まえて、MyServiceConsumer コンポーネント実装します。この例では、
// onExecute() でユーザからの入力待ちを行い、各オペレーションに対応したコ
// マンドを受け取り、コマンドに応じてリモートのプロバイダのオペレーション
// を呼び出し結果を返すといった簡単なものです。

Based on the above, let's implement a MyServiceConsumer component.  In this example, the component receives commands assigned to each operation defined in the interface in the onExecute() function, and call actual operation in the remote object according to the received command and return results.

// では、まずユーザに利用できるコマンドを提示する部分からみていきます。

So, let's see a part that shows available command to users.

RTC::ReturnCode_t MyServiceConsumer::onExecute(RTC::UniqueId ec_id)
{
  try
    {
      std::cout << std::endl;
      std::cout << "Command list: " << std::endl;
      std::cout << " echo [msg]       : echo message." << std::endl;
      std::cout << " set_value [value]: set value." << std::endl;
      std::cout << " get_value        : get current value." << std::endl;
      std::cout << " get_echo_history : get input messsage history." << std::endl;
      std::cout << " get_value_history: get input value history." << std::endl;
      std::cout << "> ";
      
      std::string args;
      std::string::size_type pos;
      std::vector<std::string> argv;
      std::getline(std::cin, args);

// まず、上で述べたようにコンシューマが発する例外を捕捉するためにtry節で囲
// みます。利用可能なコマンドリストを表示して、ユーザの入力をgetline()関数
// で受け取っています。

As mentioned above, in order to catch exceptions from consumer please put the code into a "try" block.  This code is showing available command list and getting input from user by getline() function.

      
      pos = args.find_first_of(" ");
      if (pos != std::string::npos)
        {
          argv.push_back(args.substr(0, pos));
          argv.push_back(args.substr(++pos));
        }
      else
        {
          argv.push_back(args);
        }

// これらのコマンドのうち、引数を取るものは echo と set_value だけで、かつ
// これらのコマンドは引数を一つだけとります。受け取った文字列を最初の空白
// で分割し、argv[0] = コマンド、argv[1] = 引数として string の vector に
// 格納します。echo, set_value コマンドでは argv[1] を引数として利用し、他
// のコマンドでは単純に無視することにします。

Only "echo" and "set_value" commands receives argument in the command set, and these commands have only one argument.  Separating received character string by blank character, two strings are stored as argv[0] = command and argv[1] = argument.  argv[1] is used as argument in the echo and set_value command, and for other command argv[1] is just ignored.

        
      if (argv[0] == "echo" && argv.size() > 1)
        {
          CORBA::String_var retmsg;
          retmsg = m_myservice0->echo(argv[1].c_str());
          std::cout << "echo return: " << retmsg << std::endl;
          return RTC::RTC_OK;
        }

// echo コマンドの実装です。argv[0] が ''echo'' の場合、argv[1] を引数にし
// て echo() 関数を呼び出します。echo() のCORBAのstring型の戻り値を受け取
// るための変数として、retmsg を宣言しています。echo() の戻り値の所有権は
// こちら側にあるので、受け取った後に適切に領域を解放する必要があるのです
// が、String_var 型のスマートポインタを利用すると、不要になった時点で適切
// に領域解放を行ってくれます。戻り値を表示して、return RTC::RTC_OK として
// onExecute() 関数を抜けています。

This is an implementation of echo command.  In case that argv[0] is "echo", echo() function is called with argument from argv[1].  In this function, CORBA's string type variable "retmsg" is declared to receive return value from echo() function.  Since the ownership of the return value from echo() function is here, you have to release memory properly after used.  However, if String_var type smart pointer is used in this context, memory will be released automatically when it is not used any more.  So this code just prints returned value and end the onExecute() function with return RTC::RTC_OK.

      if (argv[0] == "set_value" && argv.size() > 1)
        {
          CORBA::Float val(atof(argv[1].c_str()));
          m_myservice0->set_value(val);
          std::cout << "Set remote value: " << val << std::endl;
          return RTC::RTC_OK;
        }

// set_value コマンドの実装です。引数 argv[1] の文字列をCORBA::Float 型に
// 変換して、set_value() オペレーションの引数に与えています。

This is "set_value" command implementation. After converting argument argv[1] to CORBA::Float, it is given to set_value() operation as an argument.

        
      if (argv[0] == "get_value")
        {
          std::cout << "Current remote value: "
                    << m_myservice0->get_value() << std::endl;
          return RTC::RTC_OK;
        }

// get_value コマンドは set_value コマンドで設定した値を取得します。
// get_value() オペレーションは、戻り値が CORBA::Float で値渡しのためオブ
// ジェクトの所有権などは特に考えなくとも構いません。ここでは、戻り値をそ
// のまま std::cout でコンソールに表示させています。

"get_value" command gets a value that is set by "set_value" command. get_value() operation has a CORBA::Float return value, and because it is passed by value, concerning about ownership of object is not necessary.  Here, returned value is directly printed out to the console by std::cout.

      if (argv[0] == "get_echo_history")
        {
          EchoList_var elist = m_myservice0->get_echo_history();
          for (CORBA::ULong i(0), len(elist.length(); i <len; ++i)
          {
            std::cout << elist[i] << std::endl;
          }
          return RTC::RTC_OK;
        }

// get_echo_history コマンドでは、get_echo_history() の結果を受け取り、そ
// れまで echo コマンドで引数に与えられた文字列のリストを返しています。
// get_echo_history() 関数の戻り値は CORBA のシーケンス型である EchoList
// です。シーケンス型についてもスマートポインタである _var 型が定義されて
// いますので、これを利用します。配列の長さを取得するための length() 関数
// が利用できるので、長さを調べて for 文ですべての要素を表示しています。シー
// ケンス型の_var型では、上のように[]オペレータを利用してC言語の配列のよう
// に各要素にアクセスできます。

get_echo_history command receives a result from get_echo_history() operation, and print a list of strings that were given to echo-command before.  The return value of get_echo_history() operation is EchoList CORBA sequence type.  Since the _var smart pointer type is also defined for sequence type, it is used there.  A "length()" function which returns current length of the array is available, and getting the length of the array by it all the values are printed out by "FOR" sentence.  In the _var object of sequence type, "[]" operator is available as shown in above example, and each element can be accessed like in C language.

      if (argv[0] == "get_value_history")
        {
          ValueList_var vlist = m_myservice0->get_value_history();
          for (CORBA::ULong i(0), len(vlist.length()); i < len; ++i)
          {
            std::cout << vlist[i] << std::endl;
          }
          return RTC::RTC_OK;
        }

// 最後に、get_value_history コマンドです。get_value_history() オペレーショ
// ンを呼び出し、これまで設定されたあたりのリストを表示します。
// get_value_hitory() 関数の戻り値は CORBA::Float のシーケンス型の
// ValueList です。要素は CORBA::Float のためオブジェクトの所有権等といっ
// たことは考えなくてもよいのですが、シーケンス型はそれ自身オブジェクトで
// すので、所有権を考慮しなければならないのでここでは _var 型の変数で受け
// 取っています。

Let's see get_value_history command implementation.  Calling get_value_history() operation, it prints out a list of values which were set before.  The return value of the get_value_history() operation is ValueList, which is sequence type of CORBA::Float.  Since each element is CORBA::Float, you don't need to consider the ownership of objects.  However, since sequence type variable is an object to be considered its ownership, it is assigned to _var type variable.

 std::cout << "Invalid command or argument(s)." << std::endl;
     }
   catch (CORBA::SystemException &e)
     {
       std::cout << "No service connected." << std::endl;
     }
   return RTC::RTC_OK;
 }

// 最後に、上のどれにも当てはまらなかったコマンドの場合に、メッセージを出
// しています。また、コンシューマに参照がセットされていない場合の例外を含
// めて捕捉するための catch 節があります。

At the end, a message is printed out for unknown or invalid command case.  And you can see "catch" block to catch exception from the consumer including reference not assigned exception.

// 以上、コンシューマによるオペレーションの呼び方について簡単な例を交えて
// 説明しました。コンシューマを利用する際には、必ずしもオブジェクト参照が
// セットされているとは限らないので、必ず例外を捕捉し対処することと、各オ
// ペレーションの呼び出しが、CORBAのルールに基づいて行われることに留意して
// ください。

How to call operations from consumer was explained sprinkled with some simple example in above.  In case of using consumers, it must be noted that exception from consumers should always be caught and should be handled them since object reference is not always set to it.  And note that every operation call would be done by CORBA's rule.
