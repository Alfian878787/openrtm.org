*RTCプログラミングの流れ
OpenRTM-aist は、コンポーネントを開発したいユーザ(コンポーネントデベロッパ) が持つ既存のソフトウエア資産、あるいは新たに作成したソフトウエアを容易にRTコンポーネント(RTC)化するためのフレームワークを提供します。
コンポーネント作成の大まかな流れは下図 のようになります。

&br;&br;
#ref(ComponentDevelFlow.png,nolink,center)
CENTER:''RTコンポーネントの開発フロー''
&br;&br;

コンポーネントデベロッパは、既存のソフトウエア資産のライブラリ関数・クラスライブラリ等をコンポーネントフレームワークに埋め込みコンポーネントを作成します。こうすることで、既存のソフトウエア資源をソフトウエア部品であるRTコンポーネントとして作成しておき、様々な場面で再利用することが出来るようになります。作成されたRTコンポーネントは、ネットワーク上の適切な場所に配置して、分散オブジェクトとしてネットワーク上の任意の場所から利用することができます。 

図に示すように、RTコンポーネントフレームワークに則って作成されたRTコンポーネントは大きく分けて2つのバイナリファイルとして作成することが出来ます。スタンドアロンRTコンポーネント (Standalone RT-Component) は、単一ファイルでそのまま実行できる実行形式のバイナリです。
ローダブルモジュールRTコンポーネント (Loadable Module RT-Component) は動的にロード可能なローダブルモジュール形式のバイナリファイルです。 
RTコンポーネントはこれらの2つの形式で作成、配布、実行することができます。 

*RTCプログラミングの基礎
通常のプログラミングとRTコンポーネントのプログラミングには、幾つかの大きな違いがあります。


**main関数が無いプログラム
RTコンポーネントのプログラムには通常のプログラムとは異なり、main関数がありません。
代わりに1つのRTコンポーネントは、通常ある特別な基底クラスを継承した一つのクラスとして実装されます。

RTコンポーネントにさせたい処理は、その基底クラスのメンバ関数(メソッド)をオーバーライドする形で記述します。
例えば、初期化のような処理は、onInitializeという関数の中に記述します。あるいは、終了時に行いたい処理であれば、onFinalize という関数の中に記述します。

 ReturnCode_t MyComponent::onInitialize()
 {
   // 初期化処理など
 }
 ReturnCode_t MyComponent::onFinalize()
 {
   // 終了処理など
 }

では、ここで書いた初期化処理や、終了処理はいつ実行されるのでしょうか？
それを知るためには、RTコンポーネントのライフサイクルを知る必要があります。

**コンポーネント・ライフサイクル
あるRTコンポーネントが生まれてから死ぬまでの一連の流れのことを、コンポーネントのライフサイクルと呼びます。

コンポーネントには基本的に

-生成状態(Created)
-活動状態(Alive)
-終了状態

の3つの状態を持ちます。
(Alive状態は内部にさらに状態を持ちます(後述)。)

コンポーネントは1つのクラスであることは上で述べました。
従って、コンポーネントが生成されるということは、オブジェクト(インスタンス)が生成されることとほぼ同じです。
通常、RTコンポーネントはマネージャ(RTCマネージャ)によって生成され、以後マネージャがRTコンポーネントのライフサイクルを管理します。

具体的には、マネージャはRTコンポーネントのインスタンス生成後、上で述べたonInitialize関数をコールします。
また、RTコンポーネントが終了するとき、マネージャはonFinalize関数をコールします。
このように、RTコンポーネントのライフサイクルの中の特定のタイミングに割り当てられた処理(これをアクションと呼ぶ)毎に、必要な処理を記述することで、RTコンポーネントのプログラミングを行います。
**実行コンテキスト
通常プログラムを実行するとスレッドが割り当てられ、そのスレッドがプログラムとして記述された処理を実行します。
ロボットを制御するプログラムでは、通常スレッドにより実行されるループ(制御ループや処理ループ)を持ち、センサデータを処理したり、アクチュエータを制御し続けます。
こうした、何かを処理したり制御したりするための主たる処理をRTコンポーネントではコアロジックと呼びます。

RTコンポーネントは、生成されAlive状態になると通常一つのスレッドが割り当てられ、RTコンポーネントとしてのメインの処理(コアロジック)を実行します。
このスレッドをRTコンポーネントでは実行コンテキスト(ExecutionContext)と呼びます。
実際には、実行コンテキストはスレッドそのものではなく、スレッドを抽象的に表現したもので実行周期や状態を持ちます。
つまり、RTコンポーネントが生成されると実行コンテキストがRTコンポーネントに関連付けられ、コアロジックが駆動されることにより、RTコンポーネントが何らかの処理(例えばロボットを制御するなど)を行います。

**RTCの状態遷移 
上で述べたように、RTコンポーネントは状態を持ち、その状態や遷移に割り当てられたアクションとして処理を記述します。
下図はRTコンポーネントの状態遷移図(UMLのステートマシン図)を表しています。

&br;&br;
#ref(RTCStateMachine040.png,nolink,center)
CENTER:''RTコンポーネントの状態遷移''
&br;&br;

CreatedとAliveはRTコンポーネントの状態です。
Alive状態の中にも幾つかの状態が存在しています。

***スレッドの停止状態と実行状態 
まず、Alive状態内部の上部のStoppedとRunning状態から見ていきます。

&br;&br;
#ref(RTCStateMachineStartStop.png,nolink,center)
CENTER:''スレッドの停止状態と実行状態''
&br;&br;

これは、実行コンテキストをスレッドとして見たとき、スレッドが停止中(Stopped)か実行中(Running)かを表す状態です。

停止状態(Stopped)にある実行コンテキストがstartイベントを受け取ると、RTコンポーネントのonStartupを実行して実行状態(Running)に遷移します。
逆にstopイベントにより、実行コンテキストはRTコンポーネントのonShutdownを実行して停止状態(Stopped)状態に遷移します。

コアロジックのアクションは、実行状態(Running)状態のときのみ実行され、停止状態においては全てのアクションは実行されません。


***アクティブ・非アクティブ状態 
Alive状態内の下段はコアロジックのアクティブ(Active)・非アクティブ(Inactive)・エラー(Error)に関する状態遷移です。

RTコンポーネント生成直後は、RTコンポーネントは非アクティブ状態(Inactive)にあります。
RTコンポーネントをアクティブ化すると、RTコンポーネントのアクションであるonActivateがコールされアクティブ状態に遷移します。
アクティブ状態にいる間、通常RTコンポーネントのアクションonExecuteが繰り返し実行され続けます。
通常はこのonExecute内で、RTコンポーネントのメインの処理を行います。
例えば、センサからデータを読み込み他のコンポーネントへ送ったり、他のコンポーネントから受け取ったデータに基づきモータを制御したりといった、ロボットにおいて基本的な繰り返し処理はonExecuteに記述することになるでしょう。

RTコンポーネントは非アクティブ化されるか、エラーが発生するまでアクティブ状態に留まり続けます。
非アクティブ化される場合はonDeactivateがコールされ、非アクティブ状態に遷移します。
アクティブ状態の処理の中で何らかのエラーが発生した場合、RTコンポーネントのアクションであるonAbortingがコールされ、エラー状態(Error)に遷移します。

エラー状態に遷移した場合、外部からリセットが行われるまでエラー状態に留まり続けonErrorがコールされ続けます。
リセットが行われると、onResetがコールされます。
onResetの処理が成功すれば非アクティブ状態(Inactive)に遷移し、再びアクティブ状態になることが出来ますが、onResetが失敗した場合は、エラー状態に留まり続けます。

&br;&br;
#ref(RTCStateMachineActiveInactive.png,nolink,center)
CENTER:''非アクティブ状態・アクティブ状態・エラー状態''
&br;&br;

**アクションのまとめ 
RTコンポーネント開発者の主な仕事は、自分が作成しようとするコンポーネントでは、これまで述べてきたRTコンポーネントの各状態毎にどういった処理をすればよいのかを考え、それぞれのアクションに対応する関数を実装することです。
つまり、自分が作成するコンポーネントに必要な''on???''という関数だけをオーバーライドし、関数の中身を記述すればいいのです。

以下に、コンポーネントのアクションの関数と役割を示します。

|onInitialize|初期化処理.コンポーネントライフサイクルの開始時に一度だけ呼ばれる.|
|onActivated|非アクティブ状態からアクティブ化されるとき1度だけ呼ばれる.|
|onExecute|アクティブ状態時に周期的に呼ばれる.|
|onDeactivated|アクティブ状態から非アクティブ化されるとき1度だけ呼ばれる.|
|onAborting|ERROR状態に入る前に1度だけ呼ばれる.|
|onReset|エラー状態からリセットされ非アクティブ状態に移行するときに1度だけ呼ばれる.|
|onError|エラー状態にいる間周期的に呼ばれる.|
|onFinalize|コンポーネントライフサイクルの終了時に1度だけ呼ばれる.|
|onStateUpdate|onExecuteの後毎回呼ばれる.|
|onRateChanged|ExecutionContextのrateが変更されたとき呼ばれる.|
|onStartup|ExecutionContextが実行を開始するとき1度だけ呼ばれる.|
|onShutdown|ExecutionContextが実行を停止するとき1度だけ呼ばれる.|
